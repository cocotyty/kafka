/*
 *  Copyright (c) 2011 NeuStar, Inc.
 *  All rights reserved.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 *  NeuStar, the Neustar logo and related names and logos are registered
 *  trademarks, service marks or tradenames of NeuStar, Inc. All other
 *  product names, company names, marks, logos and symbols may be trademarks
 *  of their respective owners.
 */

package kafka

import (
	"bytes"
	"compress/gzip"
	"testing"
)

func TestMessageCreation(t *testing.T) {
	payload := []byte("testing")
	msg := NewMessage(payload)
	if msg.magic != 1 {
		t.Errorf("magic incorrect")
		t.Fail()
	}

	// generated by kafka-rb: e8 f3 5a 06
	expected := []byte{0xe8, 0xf3, 0x5a, 0x06}
	if !bytes.Equal(expected, msg.checksum[:]) {
		t.Fail()
	}
}

func TestMagic0MessageEncoding(t *testing.T) {
	// generated by kafka-rb:
	// test the old message format
	expected := []byte{0x00, 0x00, 0x00, 0x0c, 0x00, 0xe8, 0xf3, 0x5a, 0x06, 0x74, 0x65, 0x73, 0x74, 0x69, 0x6e, 0x67}
	length, msgsDecoded, err := Decode(expected, DefaultCodecsMap)

	if length == 0 || msgsDecoded == nil || err != nil {
		t.Fail()
	}
	msgDecoded := msgsDecoded[0]

	payload := []byte("testing")
	if !bytes.Equal(payload, msgDecoded.payload) {
		t.Fatal("bytes not equal")
	}
	chksum := []byte{0xE8, 0xF3, 0x5A, 0x06}
	if !bytes.Equal(chksum, msgDecoded.checksum[:]) {
		t.Fatal("checksums do not match")
	}
	if msgDecoded.magic != 0 {
		t.Fatal("magic incorrect")
	}
}

func TestMessageEncoding(t *testing.T) {

	payload := []byte("testing")
	msg := NewMessage(payload)

	// generated by kafka-rb:
	expected := []byte{0x00, 0x00, 0x00, 0x0d, 0x01, 0x00, 0xe8, 0xf3, 0x5a, 0x06, 0x74, 0x65, 0x73, 0x74, 0x69, 0x6e, 0x67}
	if !bytes.Equal(expected, msg.Encode()) {
		t.Fatalf("expected: % X\n but got: % X", expected, msg.Encode())
	}

	// verify round trip
	length, msgsDecoded, err := DecodeWithDefaultCodecs(msg.Encode())

	if length == 0 || msgsDecoded == nil || err != nil {
		t.Fatal("message is nil")
	}
	msgDecoded := msgsDecoded[0]

	if !bytes.Equal(msgDecoded.payload, payload) {
		t.Fatal("bytes not equal")
	}
	chksum := []byte{0xE8, 0xF3, 0x5A, 0x06}
	if !bytes.Equal(chksum, msgDecoded.checksum[:]) {
		t.Fatal("checksums do not match")
	}
	if msgDecoded.magic != 1 {
		t.Fatal("magic incorrect")
	}
}

func TestCompressedMessageEncodingCompare(t *testing.T) {
	payload := []byte("testing")
	uncompressedMsgBytes := NewMessage(payload).Encode()

	msgGzipBytes := NewMessageWithCodec(uncompressedMsgBytes, DefaultCodecsMap[GZIP_COMPRESSION_ID]).Encode()
	msgDefaultBytes := NewCompressedMessage(payload).Encode()
	if !bytes.Equal(msgDefaultBytes, msgGzipBytes) {
		t.Fatalf("uncompressed: % X \npayload: % X bytes not equal", msgDefaultBytes, msgGzipBytes)
	}
}

func TestCompressedMessageEncoding(t *testing.T) {
	payload := []byte("testing")

	// Encode message into kafka frame with no compression
	uncompressedMsgBytes := NewMessage(payload).Encode()

	// Take the raw kafka frame, gzip it and take the result as payload for a new kafka frame.
	// Not sure why we'd want to test this as opposed to a normal message.
	msg := NewMessageWithCodec(uncompressedMsgBytes, DefaultCodecsMap[GZIP_COMPRESSION_ID])

	expectedPayload := []byte{0x1F, 0x8B, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04,
		0xFF, 0x00, 0x11, 0x00, 0xEE, 0xFF, 0x00, 0x00, 0x00, 0x0D, 0x01, 0x00,
		0xE8, 0xF3, 0x5A, 0x06, 0x74, 0x65, 0x73, 0x74, 0x69, 0x6E, 0x67, 0x01,
		0x00, 0x00, 0xFF, 0xFF, 0x0C, 0x6A, 0x82, 0x91, 0x11, 0x00, 0x00, 0x00}

	expectedHeader := []byte{0x00, 0x00, 0x00, 0x33, 0x01, 0x01, 0x1B, 0x20, 0xC9, 0x02}

	expected := make([]byte, len(expectedHeader)+len(expectedPayload))
	n := copy(expected, expectedHeader)
	copy(expected[n:], expectedPayload)

	if msg.compression != 1 {
		t.Fatalf("expected compression: 1 but got: %b", msg.compression)
	}

	zipper, _ := gzip.NewReader(bytes.NewBuffer(msg.payload))
	uncompressed := make([]byte, 100)
	n, _ = zipper.Read(uncompressed)
	uncompressed = uncompressed[:n]
	zipper.Close()

	if !bytes.Equal(uncompressed, uncompressedMsgBytes) {
		t.Fatalf("uncompressed: % X \npayload: % X bytes not equal", uncompressed, uncompressedMsgBytes)
	}

	if !bytes.Equal(expected, msg.Encode()) {
		t.Fatalf("expected encoded: \n\t% 20X\n but got: \n\t% 20X", expected, msg.Encode())
	}
}

func TestCompressedMessageEncodingRoundTrip(t *testing.T) {
	payload := []byte("testing")

	// Encode payload into kafka frame with no compression
	uncompressedMsgBytes := NewMessage(payload).Encode()

	// Take the raw kafka frame, gzip it and take the result as payload for a new kafka frame.
	// Not sure why we'd want to test this as opposed to a normal message.
	msg := NewMessageWithCodec(uncompressedMsgBytes, DefaultCodecsMap[GZIP_COMPRESSION_ID])

	// verify round trip
	length, msgsDecoded, err := Decode(msg.Encode(), DefaultCodecsMap)
	if length == 0 || len(msgsDecoded) == 0 || err != nil {
		t.Fatal("message is nil")
	}
	msgDecoded := msgsDecoded[0]

	if !bytes.Equal(msgDecoded.payload, payload) {
		t.Fatal("bytes not equal")
	}
	chksum := []byte{0xE8, 0xF3, 0x5A, 0x06}
	if !bytes.Equal(chksum, msgDecoded.checksum[:]) {
		t.Fatalf("checksums do not match, expected: % X but was: % X",
			chksum, msgDecoded.checksum[:])
	}
	if msgDecoded.magic != 1 {
		t.Fatal("magic incorrect")
	}
}

func TestLongCompressedMessageRoundTrip(t *testing.T) {
	payloadBuf := bytes.NewBuffer([]byte{})
	// make the test bigger than buffer allocated in the Decode
	for i := 0; i < 15; i++ {
		payloadBuf.Write([]byte("testing123 "))
	}

	uncompressedMsgBytes := NewMessage(payloadBuf.Bytes()).Encode()
	msg := NewMessageWithCodec(uncompressedMsgBytes, DefaultCodecsMap[GZIP_COMPRESSION_ID])

	zipper, _ := gzip.NewReader(bytes.NewBuffer(msg.payload))
	uncompressed := make([]byte, 200)
	n, _ := zipper.Read(uncompressed)
	uncompressed = uncompressed[:n]
	zipper.Close()

	if !bytes.Equal(uncompressed, uncompressedMsgBytes) {
		t.Fatalf("uncompressed: % X \npayload: % X bytes not equal",
			uncompressed, uncompressedMsgBytes)
	}

	// verify round trip
	length, msgsDecoded, err := Decode(msg.Encode(), DefaultCodecsMap)

	if nil != err {
		t.Fatal(err)
	}
	if length == 0 || msgsDecoded == nil {
		t.Fatal("message is nil")
	}
	msgDecoded := msgsDecoded[0]

	if !bytes.Equal(msgDecoded.payload, payloadBuf.Bytes()) {
		t.Fatal("bytes not equal")
	}
	if msgDecoded.magic != 1 {
		t.Fatal("magic incorrect")
	}
}

func TestLongCompressedMessageRoundTripSnappy(t *testing.T) {
	payloadBuf := bytes.NewBuffer([]byte{})
	// make the test bigger than buffer allocated in the Decode
	for i := 0; i < 15; i++ {
		payloadBuf.Write([]byte("testing123 "))
	}

	uncompressedMsgBytes := NewMessage(payloadBuf.Bytes()).Encode()
	msg := NewMessageWithCodec(uncompressedMsgBytes, DefaultCodecsMap[SNAPPY_COMPRESSION_ID])

	// verify round trip
	length, msgsDecoded, err := Decode(msg.Encode(), DefaultCodecsMap)

	if length == 0 || msgsDecoded == nil || err != nil {
		t.Fatal("message is nil")
	}
	msgDecoded := msgsDecoded[0]

	if !bytes.Equal(msgDecoded.payload, payloadBuf.Bytes()) {
		t.Fatal("bytes not equal")
	}
	if msgDecoded.magic != 1 {
		t.Fatal("magic incorrect")
	}
}

func TestMultipleCompressedMessages(t *testing.T) {
	msgs := []*Message{
		NewMessage([]byte("testing")),
		NewMessage([]byte("multiple")),
		NewMessage([]byte("messages")),
	}
	msg := NewCompressedMessages(msgs...)

	length, msgsDecoded, err := DecodeWithDefaultCodecs(msg.Encode())
	if length == 0 || msgsDecoded == nil || err != nil {
		t.Fatal("msgsDecoded is nil")
	}

	// make sure the decompressed messages match what was put in
	for index, decodedMsg := range msgsDecoded {
		if !bytes.Equal(msgs[index].payload, decodedMsg.payload) {
			t.Fatalf("Payload doesn't match, expected: % X but was: % X\n",
				msgs[index].payload, decodedMsg.payload)
		}
	}
}

func TestRequestHeaderEncoding(t *testing.T) {
	broker := newBroker("localhost:9092", "test", 0)
	request := broker.EncodeRequestHeader(REQUEST_PRODUCE)

	// generated by kafka-rb:
	expected := []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x74, 0x65, 0x73, 0x74,
		0x00, 0x00, 0x00, 0x00}

	if !bytes.Equal(expected, request.Bytes()) {
		t.Errorf("expected length: %d but got: %d", len(expected), len(request.Bytes()))
		t.Errorf("expected: %X\n but got: %X", expected, request)
		t.Fail()
	}
}

func TestPublishRequestEncoding(t *testing.T) {
	payload := []byte("testing")
	msg := NewMessage(payload)

	pubBroker := NewBrokerPublisher("localhost:9092", "test", 0)
	request := pubBroker.broker.EncodePublishRequest(msg)

	// generated by kafka-rb:
	expected := []byte{0x00, 0x00, 0x00, 0x21, 0x00, 0x00, 0x00, 0x04, 0x74, 0x65, 0x73, 0x74,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x0d,
		/* magic  comp  ......  chksum ....     ..  payload .. */
		0x01, 0x00, 0xe8, 0xf3, 0x5a, 0x06, 0x74, 0x65, 0x73, 0x74, 0x69, 0x6e, 0x67}

	if !bytes.Equal(expected, request) {
		t.Errorf("expected length: %d but got: %d", len(expected), len(request))
		t.Errorf("expected: % X\n but got: % X", expected, request)
		t.Fail()
	}
}

func TestConsumeRequestEncoding(t *testing.T) {

	pubBroker := NewBrokerPublisher("localhost:9092", "test", 0)
	request := pubBroker.broker.EncodeConsumeRequest(0, 1048576)

	// generated by kafka-rb, encode_request_size + encode_request
	expected := []byte{0x00, 0x00, 0x00, 0x18, 0x00, 0x01, 0x00, 0x04, 0x74,
		0x65, 0x73, 0x74, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00}

	if !bytes.Equal(expected, request) {
		t.Errorf("expected length: %d but got: %d", len(expected), len(request))
		t.Errorf("expected: % X\n but got: % X", expected, request)
		t.Fail()
	}
}

func TestCorruptPacket(t *testing.T) {
	total, msgs, err := DecodeWithDefaultCodecs([]byte{0x00, 0x00, 0x00, 0x18})
	if total != 0 {
		t.Errorf("total should be 0, but was: %d", total)
		t.Fail()
	}
	if len(msgs) != 0 {
		t.Errorf("msgs should be 0, but was: %d", len(msgs))
		t.Fail()
	}
	if nil == err {
		t.Error("was expecting a non-nil error")
		t.Fail()
	}
}
